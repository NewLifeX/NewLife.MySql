# NewLife.MySql 架构设计

## 1. 概述

NewLife.MySql 是一个轻量级高性能 MySql 驱动，基于 ADO.NET 标准接口实现，直接通过 TCP 通信实现 MySQL 协议层，无需依赖官方驱动或第三方库。

**设计目标**：轻量级高性能，只支持 ADO.NET 标准的增删改查、事务、参数化查询、存储过程和批量操作，无需支持 EF、集群或设计器等功能。

## 2. 整体架构

```
┌─────────────────────────────────────────────┐
│              应用层 (Application)             │
│  DAL / XCode / 直接使用 ADO.NET 接口          │
└─────────────────────┬───────────────────────┘
                      │
┌─────────────────────▼───────────────────────┐
│            ADO.NET 标准接口层                  │
│  MySqlConnection  MySqlCommand               │
│  MySqlDataReader  MySqlTransaction           │
│  MySqlParameter   MySqlParameterCollection   │
│  MySqlClientFactory  MySqlDataAdapter        │
└─────────────────────┬───────────────────────┘
                      │
┌─────────────────────▼───────────────────────┐
│              连接池层 (Pool)                   │
│  MySqlPoolManager  MySqlPool                 │
│  按连接字符串分池，复用 SqlClient 连接          │
└─────────────────────┬───────────────────────┘
                      │
┌─────────────────────▼───────────────────────┐
│            协议层 (Protocol)                   │
│  SqlClient         Authentication            │
│  SchemaProvider    WelcomeMessage             │
│  Response          MySqlColumn               │
│  BinaryHelper      ClientFlags               │
└─────────────────────┬───────────────────────┘
                      │
┌─────────────────────▼───────────────────────┐
│            网络层 (Network)                    │
│  TcpClient + NetworkStream                   │
│  SslStream (可选 TLS 加密)                    │
└─────────────────────────────────────────────┘
```

## 3. 核心类关系

### 3.1 ADO.NET 标准接口

| 类名 | 基类 | 职责 |
|------|------|------|
| `MySqlClientFactory` | `DbProviderFactory` | 工厂类，创建连接/命令/参数等对象，管理连接池 |
| `MySqlConnection` | `DbConnection` | 数据库连接，管理生命周期和状态 |
| `MySqlCommand` | `DbCommand` | SQL 命令执行，参数化查询，存储过程调用 |
| `MySqlDataReader` | `DbDataReader` | 结果集读取，逐行读取数据，多结果集遍历 |
| `MySqlTransaction` | `DbTransaction` | 事务管理，提交/回滚，自动回滚 |
| `MySqlParameter` | `DbParameter` | 查询参数，支持输入/输出方向 |
| `MySqlParameterCollection` | `DbParameterCollection` | 参数集合 |
| `MySqlConnectionStringBuilder` | `DbConnectionStringBuilder` | 连接字符串解析 |
| `MySqlDataAdapter` | `DbDataAdapter` | 数据适配器，DataSet/DataTable 填充和更新 |

### 3.2 协议层

| 类名 | 职责 |
|------|------|
| `SqlClient` | 核心协议实现，管理 TCP 连接、收发数据包、协议解析 |
| `Authentication` | MySQL 认证流程（mysql_native_password / caching_sha2_password） |
| `Response` | 响应包封装，判断 OK/Error/EOF |
| `WelcomeMessage` | 握手欢迎消息解析 |
| `SchemaProvider` | Schema 信息查询（数据库/表/列/索引） |
| `MySqlColumn` | 结果集列元数据 |

### 3.3 辅助类

| 类名 | 职责 |
|------|------|
| `BinaryHelper` | MySQL 协议二进制读写扩展方法 |
| `MySqlDbType` | MySQL 数据类型枚举 |
| `ClientFlags` | 客户端能力标志位 |
| `ServerStatus` / `ServerStatusFlags` | 服务器状态标志位 |
| `DbCmd` | MySQL 命令类型枚举 |
| `MySqlException` | MySQL 异常类 |
| `QueryResult` / `RowResult` | 查询结果和行读取结果 |

## 4. MySQL 协议版本支持

### 4.1 协议概述

MySQL 使用自定义的二进制协议（MySQL Client/Server Protocol），基于 TCP 通信。协议版本号为 10（Protocol Version 10），从 MySQL 3.21 沿用至今。NewLife.MySql 支持 MySQL 5.x 到 9.0 的全部主要版本。

### 4.2 版本差异

| 特性 | MySQL 5.5 | MySQL 5.6 | MySQL 5.7 | MySQL 8.0 | MySQL 8.4 | MySQL 9.0 |
|------|-----------|-----------|-----------|-----------|-----------|-----------|
| 默认认证 | native_password | native_password | native_password | caching_sha2 | caching_sha2 | caching_sha2 |
| COM_RESET_CONNECTION | ✗ | ✗ | ✓ | ✓ | ✓ | ✓ |
| JSON 类型 | ✗ | ✗ | ✓ | ✓ | ✓ | ✓ |
| 多因子认证 (MFA) | ✗ | ✗ | ✗ | ✓ (8.0.27+) | ✓ | ✓ |
| TLS 1.3 | ✗ | ✗ | ✗ | ✓ (8.0.16+) | ✓ | ✓ |
| mysql_native_password | 默认 | 默认 | 默认 | 可用 | 废弃 | 已移除 |
| 压缩协议 | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |

### 4.3 认证方式演进

| 认证方式 | 引入版本 | 默认版本 | 状态 | 说明 |
|---------|---------|---------|------|------|
| `mysql_native_password` | MySQL 4.1 | 5.x~5.7 | MySQL 9.0 已移除 | SHA1 双重哈希，20 字节响应 |
| `caching_sha2_password` | MySQL 8.0 | 8.0+ | 当前默认 | SHA256 哈希，首次需 RSA/TLS 传输密码 |
| `sha256_password` | MySQL 5.6 | - | 8.0 废弃 | 纯 SHA256，每次需 RSA/TLS |

**认证流程**：

1. 服务器发送欢迎包，包含认证方法名和随机种子
2. 客户端根据认证方法计算密码哈希并发送
3. 如果服务器返回 Auth Switch（0xFE），则切换到指定的认证方法重新认证
4. `caching_sha2_password` 首次连接如果缓存未命中，需要通过 RSA 公钥加密密码或通过 TLS 通道传输

### 4.4 协议包格式

```
+-------------------+-------+-----------+
|  payload_length   |  seq  |  payload  |
|     3 bytes       | 1byte | N bytes   |
+-------------------+-------+-----------+
```

- `payload_length`：3 字节小端序，最大 16MB（0xFFFFFF）
- `seq`：1 字节序列号，每次请求重置为 0，每个包递增
- 超过 16MB 的数据包自动拆分为多个 16MB 帧

## 5. 协议交互流程

### 5.1 连接建立

```
Client                          Server
  │                               │
  │◄──── Welcome Packet ──────────│  服务器发送欢迎消息（协议版本/能力/种子）
  │                               │
  │  [可选] SSL Request ─────────►│  如果 SslMode != None
  │◄──── TLS Handshake ──────────►│  升级为加密连接
  │                               │
  │  Auth Response ──────────────►│  发送认证信息（用户名/加密密码/数据库）
  │◄──── OK / Auth Switch ───────│  认证结果（可能需要切换认证方式）
  │                               │
  │  [可选] RSA 公钥请求 ─────────►│  caching_sha2_password 全量认证
  │◄──── RSA 公钥 ───────────────│
  │  加密密码 ───────────────────►│
  │◄──── OK ─────────────────────│
  │                               │
  │  SHOW VARIABLES ─────────────►│  获取服务器变量配置
  │◄──── Result Set ─────────────│  max_allowed_packet / charset 等
  │                               │
```

### 5.2 查询执行

```
Client                          Server
  │                               │
  │  COM_QUERY(SQL) ─────────────►│  发送 SQL 查询
  │                               │
  │  [查询结果]                     │
  │◄──── Column Count ───────────│  列数量
  │◄──── Column Definitions ─────│  列定义 × N
  │◄──── EOF ────────────────────│  列定义结束
  │◄──── Row Data ───────────────│  行数据 × M（文本协议，每列 length-encoded string）
  │◄──── EOF ────────────────────│  结果集结束（状态标志含 MORE_RESULTS 标志）
  │                               │
  │  [非查询结果]                   │
  │◄──── OK Packet ──────────────│  affected_rows + last_insert_id + status_flags
  │                               │
```

### 5.3 多语句执行（批量操作）

开启 `MULTI_STATEMENTS` 能力后，可一次发送多条 SQL，服务端按顺序返回多个结果集：

```
Client                          Server
  │                               │
  │  COM_QUERY(SQL1;SQL2;SQL3) ──►│  发送多条 SQL（分号分隔）
  │                               │
  │◄──── Result1 (OK/ResultSet) ─│  第一条 SQL 结果，status_flags 含 MORE_RESULTS
  │◄──── Result2 (OK/ResultSet) ─│  第二条 SQL 结果
  │◄──── Result3 (OK/ResultSet) ─│  第三条 SQL 结果，status_flags 不含 MORE_RESULTS
  │                               │
```

### 5.4 存储过程调用

```
Client                          Server
  │                               │
  │  CALL proc(@p1, @p2) ───────►│  调用存储过程
  │                               │
  │◄──── ResultSet(s) ───────────│  过程中的 SELECT 结果（0~N 个）
  │◄──── OK Packet ──────────────│  最终状态，status_flags 含 MORE_RESULTS
  │◄──── OK Packet ──────────────│  CALL 语句本身的 OK 包
  │                               │
  │  [读取输出参数]                  │
  │  SELECT @p2 ─────────────────►│  读取 OUT 参数值
  │◄──── ResultSet ──────────────│
  │                               │
```

### 5.5 事务流程

```
Client                          Server
  │                               │
  │  SET TRANSACTION ... ────────►│  设置隔离级别
  │◄──── OK ─────────────────────│
  │                               │
  │  BEGIN ──────────────────────►│  开始事务
  │◄──── OK ─────────────────────│
  │                               │
  │  INSERT/UPDATE/DELETE ───────►│  业务 SQL
  │◄──── OK ─────────────────────│
  │                               │
  │  COMMIT / ROLLBACK ──────────►│  提交或回滚
  │◄──── OK ─────────────────────│
  │                               │
```

### 5.6 管道化批量执行（Pipeline）

通过连接字符串 `Pipeline=true` 启用真管道化执行。基于 COM_STMT_PREPARE + COM_STMT_EXECUTE 二进制协议，先批量发送所有 EXECUTE 请求包，再按顺序批量读取响应。

#### 串行模式（默认）

```
Client                          Server
  │                               │
  │  COM_STMT_EXECUTE(1) ───────►│  发送第 1 组参数
  │◄──── OK ─────────────────────│  接收第 1 个响应
  │  COM_STMT_EXECUTE(2) ───────►│  发送第 2 组参数
  │◄──── OK ─────────────────────│  接收第 2 个响应
  │  COM_STMT_EXECUTE(N) ───────►│  发送第 N 组参数
  │◄──── OK ─────────────────────│  接收第 N 个响应
  │                               │
  │  耗时 ≈ N × (发送延迟 + 处理时间 + 接收延迟)
```

#### 管道化模式（Pipeline=true）

```
Client                          Server
  │                               │
  │  ── Phase 1: 批量发送 ──       │
  │  COM_STMT_EXECUTE(1) ───────►│  连续发送，不等响应
  │  COM_STMT_EXECUTE(2) ───────►│  TCP 协议栈合并小包
  │  COM_STMT_EXECUTE(3) ───────►│
  │  ...                          │
  │  COM_STMT_EXECUTE(N) ───────►│  最后一个包 Flush
  │                               │
  │  ── Phase 2: 批量读取 ──       │  服务器按顺序处理并返回
  │◄──── OK(1) ──────────────────│  逐个读取 OK 包
  │◄──── OK(2) ──────────────────│  累加 affected_rows
  │◄──── OK(3) ──────────────────│
  │  ...                          │
  │◄──── OK(N) ──────────────────│
  │                               │
  │  耗时 ≈ 批量发送时间 + N × 处理时间 + 批量接收时间
```

#### 性能对比

| 场景 | 串行模式 | 管道化模式 | 优势 |
|------|---------|-----------|------|
| 1000 行 INSERT（内网） | ~1s | ~0.3s | 3× |
| 1000 行 UPDATE（内网） | ~1s | ~0.3s | 3× |
| 10000 行 INSERT（跨机房） | ~30s | ~3s | 10× |

> 管道化的收益主要来自减少网络往返延迟，延迟越高收益越大。

#### 协议细节

- 每个 COM_STMT_EXECUTE 包独立使用 seq=0，互不干扰
- 延迟 Flush 让 TCP 协议栈将多个小包合并为大包（Nagle 算法），减少系统调用次数
- 仅最后一个包执行 Flush，触发实际网络发送
- 服务器按 FIFO 顺序处理请求并返回 OK/Error 包
- 错误处理：管道中某个命令失败时，继续读取后续响应保持连接状态干净，最后抛出第一个错误

## 6. 连接池设计

```
MySqlClientFactory
  └── MySqlPoolManager（单例，管理所有连接池）
        └── MySqlPool（按连接字符串分组）
              ├── SqlClient #1 (active)
              ├── SqlClient #2 (idle)
              └── SqlClient #N ...
```

- 继承 `NewLife.Collections.ObjectPool<SqlClient>`
- 按连接字符串哈希分池，相同连接字符串共用同一个池
- 默认最小连接数 10，最大 100000
- 空闲超时 30 秒，全空闲超时 300 秒
- 获取连接时验证可用性（`Reset` 检查 + Active 状态检查）
- 归还时连接保持打开状态以便复用
- 服务器变量缓存 10 分钟，减少 `SHOW VARIABLES` 查询

### 6.1 ChangeDatabase 设计

**设计原则**：简单优先，通过关闭/重新打开连接实现数据库切换。

#### 实现机制

```csharp
public override void ChangeDatabase(String databaseName)
{
    // 场景1：未打开连接，直接修改设置
    if (State != ConnectionState.Open)
    {
        Setting.Database = databaseName;
        _pool = null;  // 清空连接池引用
        return;
    }

    // 场景2：已打开连接，关闭后修改设置再重新打开
    Close();
    Setting.Database = databaseName;
    Open();
}
```

#### 为什么不用 USE 命令？

**MySql.Data 的方案**：
- 使用 `COM_INIT_DB` 二进制命令（或 `USE` 语句）在当前物理连接上切换数据库
- 优点：快速，无连接开销
- 缺点：需要在归还连接池前重置数据库，否则会污染连接池

**我们的方案**：
- 使用 Close + Reopen 切换数据库
- 优点：简单，连接池映射正确，无状态跟踪
- 缺点：有连接关闭/打开的性能开销

**选择理由**：
1. `ChangeDatabase` 不是高频操作
2. 避免复杂的状态管理和连接池污染问题
3. 代码易于理解和维护

#### 连接池映射机制

`MySqlPoolManager` 使用**完整连接字符串**作为 Key：

```csharp
public MySqlPool GetPool(MySqlConnectionStringBuilder setting) 
    => _pools.GetOrAdd(setting.ConnectionString, k => CreatePool(setting));
```

**关键特性**：
- 不同的 `Database` → 不同的连接字符串 → 不同的连接池
- 例如：`Server=localhost;Database=db1;...` 和 `Server=localhost;Database=db2;...` 映射到不同的连接池

**Close + Reopen 的工作流程**：

| 步骤 | 操作 | 连接字符串 | 连接池 |
|------|------|-----------|--------|
| 1 | `Open()` | `...Database=db1...` | Pool1 |
| 2 | `ChangeDatabase("db2")` | | |
| 3 | ↳ `Close()` | | 归还到 Pool1 |
| 4 | ↳ 改 `Setting.Database` | `...Database=db2...` | - |
| 5 | ↳ `Open()` | | 从 Pool2 获取 |

**结果**：每个连接池中的连接都保持一致的数据库状态，避免污染。

#### SqlClient.SetDatabaseAsync API

除了 `MySqlConnection.ChangeDatabase` 的默认实现外，还提供了 `SqlClient.SetDatabaseAsync` 低级 API 供高级用户使用：

```csharp
public async Task SetDatabaseAsync(String databaseName, CancellationToken cancellationToken = default)
{
    // 使用 COM_INIT_DB 二进制命令
    var bytes = Encoding.GetBytes(databaseName);
    var buf = [DbCmd.INIT_DB, ...bytes];
    await SendPacketAsync(buf, cancellationToken);
    
    // 读取 OK 响应
    var rs = await ReadPacketAsync(cancellationToken);
}
```

**特点**：
- 使用 MySQL COM_INIT_DB 协议命令（命令码 0x02）
- 等效于 `USE database` 语句，但无需 SQL 解析
- 不会关闭连接，性能略优
- 不会修改连接字符串
- **仅切换服务器端的当前数据库**

**使用场景**：
```csharp
using var conn = new MySqlConnection(connStr);
conn.Open();

// 临时查询其他数据库
await conn.Client.SetDatabaseAsync("information_schema");
// 查询 information_schema.tables
...

// 切换回原数据库
await conn.Client.SetDatabaseAsync("original_db");
```

**注意事项**：
- **不适合连接池复用场景**：连接归还时不会重置数据库，可能污染连接池
- **不会更新连接字符串**：`conn.Database` 属性不会自动更新
- **适合一次性临时查询**：查询完立即关闭连接或切换回原数据库

#### 使用约束

❌ **不支持在事务中途切换数据库**：

```csharp
// ❌ 错误示例
using var conn = new MySqlConnection(connStr);
conn.Open();
using var tr = conn.BeginTransaction();
conn.ExecuteNonQuery("INSERT INTO table1 ...");
conn.ChangeDatabase("other_db");  // 事务会丢失！
conn.ExecuteNonQuery("INSERT INTO table2 ...");
tr.Commit(); // ❌ 事务已丢失
```

**原因**：`ChangeDatabase` 内部调用 `Close()` 会导致未提交的事务回滚。

✅ **推荐用法**：

```csharp
// ✅ 每个数据库使用独立连接
using var conn1 = new MySqlConnection("Server=localhost;Database=db1;...");
using var conn2 = new MySqlConnection("Server=localhost;Database=db2;...");

conn1.Open();
conn2.Open();

// 在 db1 中执行操作
conn1.ExecuteNonQuery("INSERT INTO table1 ...");

// 在 db2 中执行操作
conn2.ExecuteNonQuery("INSERT INTO table2 ...");
```

## 7. 参数化查询实现

采用客户端参数替换方式（与 MySql.Data 的默认行为一致）：

1. 解析 SQL 中的 `@参数名` 或 `?参数名` 标记
2. 跳过字符串字面量中的 `@`/`?`（避免误替换）
3. 根据参数值类型序列化为 SQL 字面量
4. 特殊字符转义（单引号、反斜杠、换行、NULL 字节等）

支持的参数类型：

| .NET 类型 | SQL 字面量 |
|-----------|-----------|
| `String` | `'hello'`（自动转义） |
| 数字类型 | `42` |
| `Boolean` | `1` / `0` |
| `DateTime` / `DateTimeOffset` | `'2025-07-01 12:30:00'` |
| `Byte[]` | `X'CAFE'` |
| `Guid` | `'01234567-89ab-cdef-...'` |
| `Enum` | 转为数字 |
| `Single` / `Double` | 往返格式（`R`） |
| `Decimal` | 原样输出 |
| `null` / `DBNull.Value` | `NULL` |

## 8. 存储过程实现

通过 `CommandType.StoredProcedure` 支持存储过程调用。

**实现机制**：

1. 将 `CommandText` 转换为 `CALL proc_name(@p1, @p2, ...)` 语句
2. 输入参数通过 `SET @p1=value` 预先设置为 MySQL 用户变量
3. 输出参数通过 `SELECT @p2` 在 CALL 执行后读取
4. 利用 MySQL 的多语句能力，一次发送 `SET...;CALL...;SELECT...`

**输出参数读取流程**：

- `ExecuteNonQueryAsync` 中，存储过程分支调用 `ReadOutputParametersAsync`
- 遍历剩余结果集，找到最后一个列数与输出参数数量匹配的结果集
- 读取第一行数据赋值回对应的 `MySqlParameter.Value`

## 9. 批量操作实现

支持四种批量执行方案，均基于预编译语句（COM_STMT_PREPARE + COM_STMT_EXECUTE）。

### 9.1 方案概览

| 方案 | API | 参数形式 | 适用场景 |
|------|-----|---------|---------|
| 字典参数集 | `ExecuteBatch` | `IList<IDictionary<String, Object?>>` | 动态参数，参数来自集合 |
| 数组绑定 | `ExecuteArrayBatch` | 每个参数 Value 为数组 | 大批量 DML，Oracle 风格 |
| 多行 VALUES | 拼接 SQL | `INSERT ... VALUES (...), (...), ...` | 纯 INSERT 批量 |
| DbBatch (.NET 6+) | `CreateBatch` | 多个独立 SQL 命令 | 不同 SQL 混合批量 |

### 9.2 字典参数集（ExecuteBatch）

同一 SQL 绑定多组参数执行，内部自动 Prepare + Execute × N：

```csharp
using var cmd = new MySqlCommand(conn, "INSERT INTO users(name, age) VALUES(@name, @age)");
cmd.Parameters.AddWithValue("name", "");
cmd.Parameters.AddWithValue("age", 0);

var paramSets = new List<IDictionary<String, Object?>>
{
    new Dictionary<String, Object?> { ["name"] = "Alice", ["age"] = 25 },
    new Dictionary<String, Object?> { ["name"] = "Bob", ["age"] = 30 },
};
var totalAffected = cmd.ExecuteBatch(paramSets);
```

### 9.3 数组绑定（ExecuteArrayBatch）

类似 Oracle 的 ArrayBindCount，参数 Value 设为数组，指定执行次数：

```csharp
using var cmd = new MySqlCommand(conn, "UPDATE users SET age=@age WHERE name=@name");
cmd.Parameters.AddWithValue("age", new Int32[] { 26, 31 });
cmd.Parameters.AddWithValue("name", new String[] { "Alice", "Bob" });
var totalAffected = cmd.ExecuteArrayBatch(2);
```

### 9.4 管道化执行

通过连接字符串 `Pipeline=true` 启用真管道化，显著提升大批量 DML 性能：

```
Server=localhost;Database=mydb;User Id=root;Password=pass;Pipeline=true;
```

**实现机制**：

1. `MySqlCommand.ExecuteBatchAsync` / `ExecuteArrayBatchAsync` 调用 `SqlClient.ExecuteStatementPipelineAsync`
2. 管道化模式：
   - Phase 1: 对每组参数调用 `BuildExecutePacket` 构建 COM_STMT_EXECUTE 包
   - Phase 1: 逐个发送包到网络缓冲区（不 Flush），最后一个包做 Flush
   - Phase 2: 按顺序读取所有 OK/Error 响应，累加 affected_rows
3. 非管道化模式：逐条发送 EXECUTE + 读取响应的快速循环

**错误处理**：管道中某个命令失败时，继续读取后续响应保持连接状态干净，最后抛出第一个错误。

### 9.5 内部实现流程

```
ExecuteBatch / ExecuteArrayBatch
  │
  ├── 自动 Prepare（若未预编译）
  │     └── ConvertToPositionalParameters → PrepareStatementAsync
  │
  ├── 提取每组参数 → MySqlParameterCollection 列表
  │     ├── ExecuteBatch: 从字典提取
  │     └── ExecuteArrayBatch: 从数组中按索引提取
  │
  ├── 调用 ExecuteStatementPipelineAsync
  │     ├── Pipeline=true:  BuildExecutePacket×N → SendPacket(flush:false)×N → Flush → ReadPacket×N
  │     └── Pipeline=false: (ExecuteStatement → ReadPacket) × N
  │
  └── 自动 Unprepare（若本次自动预编译的）
```

## 10. DataReader 架构

### 10.1 结果集类型

MySQL 多语句执行会返回多个结果，每个结果可以是：

| 结果类型 | FieldCount | 说明 | 示例 |
|---------|------------|------|------|
| **OK 包** | 0 | DML 语句的执行结果 | INSERT, UPDATE, DELETE |
| **结果集** | > 0 | 查询语句的数据结果 | SELECT |
| **错误包** | - | 执行失败 | 语法错误、权限错误 |

### 10.2 方法语义

**`ExecuteReaderAsync`**：执行 SQL 命令并返回 Reader，Reader 已定位在第一个结果集上，可立即调用 `Read()` 读取数据。

**`NextResultAsync`**：移动到下一个结果集。返回 `true` 表示成功移动（可能是 OK 包或结果集），返回 `false` 表示无更多结果。每次只移动一个结果，不跳过 OK 包，自动消费当前结果集的剩余行，自动累加 `RecordsAffected`。

**`ReadAsync`**：读取当前结果集的下一行。只在当前结果集内移动，不会自动跳到下一个结果集。

### 10.3 高层方法实现

**`ExecuteNonQueryAsync`**：基于 `ExecuteReaderAsync` 实现，消费所有结果集后返回累加的 `RecordsAffected`。存储过程分支在消费过程中同时读取输出参数。

**`ExecuteScalarAsync`**：基于 `ExecuteReaderAsync` 实现，循环查找第一个有数据的结果集，返回其第一行第一列。自动跳过 OK 包和空结果集。

### 10.4 状态管理

```
ExecuteReaderAsync 返回时：
┌────────────────────────────────┐
│ Reader 定位在第一个结果         │
│ _FieldCount = 0 或 > 0         │
│ _hasMoreResults = true/false   │
│ _allRowsConsumed = true        │
└────────────────────────────────┘
            ↓
    调用 ReadAsync()
            ↓
┌────────────────────────────────┐
│ 如果 FieldCount > 0             │
│   读取一行数据，填充 _Values    │
│   _allRowsConsumed = false     │
└────────────────────────────────┘
            ↓
    调用 NextResultAsync()
            ↓
┌────────────────────────────────┐
│ 消费当前结果集的剩余行          │
│ 读取下一个结果                  │
│ 更新 _FieldCount                │
│ 累加 _RecordsAffected           │
│ 更新 _hasMoreResults            │
└────────────────────────────────┘
```

## 11. 事务实现

- `BeginDbTransaction` 先发送 `SET TRANSACTION ISOLATION LEVEL xxx`，再发送 `BEGIN`
- `Commit` 发送 `COMMIT`，`Rollback` 发送 `ROLLBACK`
- `Dispose` 时如果未提交也未回滚，自动执行 `ROLLBACK`

支持的隔离级别：`ReadUncommitted` / `ReadCommitted` / `RepeatableRead`（默认）/ `Serializable`

## 12. SSL/TLS 实现

1. 客户端发送 SSL 请求包（含 `CLIENT_SSL` 标志的能力标志 + MaxPacket + 字符集 + 23 字节填充）
2. 升级连接为 `SslStream`，支持 TLS 1.2 和 TLS 1.3（.NET 5.0+）
3. 在加密通道上继续发送认证包

## 13. 数据类型映射

| MySQL 类型 | MySqlDbType | .NET 类型 |
|-----------|-------------|----------|
| TINYINT | `Byte` | `SByte` |
| SMALLINT | `Int16` | `Int16` |
| MEDIUMINT | `Int24` | `Int32` |
| INT | `Int32` | `Int32` |
| BIGINT | `Int64` | `Int64` |
| FLOAT | `Float` | `Single` |
| DOUBLE | `Double` | `Double` |
| DECIMAL / NUMERIC | `NewDecimal` | `Decimal` |
| VARCHAR / CHAR | `VarChar` / `String` | `String` |
| TEXT (各种) | `Text` 等 | `String` |
| BLOB (各种) | `Blob` 等 | `Byte[]` |
| DATETIME / TIMESTAMP | `DateTime` / `Timestamp` | `DateTime` |
| DATE / TIME | `Date` / `Time` | `DateTime` |
| BIT | `Bit` | `Boolean` |
| JSON | `Json` | `String` |
| ENUM | `Enum` | `String` |

## 14. 多目标框架

| 框架 | 说明 |
|------|------|
| `net45` | .NET Framework 4.5 |
| `net461` | .NET Framework 4.6.1 |
| `netstandard2.0` | .NET Standard 2.0 |
| `netstandard2.1` | .NET Standard 2.1（支持异步 Dispose、CloseAsync） |

条件编译符号：`NETFRAMEWORK`、`NET45`、`NETSTANDARD2_1_OR_GREATER`、`NET5_0_OR_GREATER`

## 15. 与同类驱动对比

### 15.1 功能对比

| 功能 | NewLife.MySql | MySqlConnector | MySql.Data (Oracle) |
|------|:------------:|:--------------:|:-------------------:|
| **许可协议** | MIT | MIT | GPL (商用需付费) |
| **零依赖** | ✓ (仅 NewLife.Core) | ✓ | ✓ |
| **真异步** | ✓ | ✓ | ✗ (sync-over-async) |
| **连接池** | ✓ | ✓ | ✓ |
| **参数化查询** | ✓ (客户端替换) | ✓ (客户端/服务端) | ✓ (客户端替换) |
| **预编译语句** | 部分 | ✓ | ✓ |
| **存储过程** | ✓ | ✓ | ✓ |
| **事务** | ✓ | ✓ | ✓ |
| **多语句/批量** | ✓ | ✓ | ✓ |
| **SSL/TLS** | ✓ | ✓ | ✓ |
| **mysql_native_password** | ✓ | ✓ | ✓ |
| **caching_sha2_password** | ✓ | ✓ | ✓ |
| **sha256_password** | ✗ | ✓ | ✓ |
| **ed25519 (MariaDB)** | ✗ | ✓ | ✗ |
| **DbBatch (.NET 6+)** | ✗ (多语句替代) | ✓ | ✗ |
| **DbDataSource (.NET 7+)** | ✗ | ✓ | ✗ |
| **EF Core 支持** | ✗ (轻量级定位) | ✓ (via Pomelo) | ✓ |
| **压缩协议** | ✗ | ✓ | ✓ |
| **负载均衡/故障转移** | ✗ (轻量级定位) | ✓ | ✓ |
| **LOAD DATA LOCAL** | ✗ | ✓ | ✓ |
| **Schema 查询** | ✓ | ✓ | ✓ |
| **DataAdapter** | ✓ | ✗ | ✓ |
| **MySQL 5.x 支持** | ✓ | ✓ (5.5+) | ✓ |
| **MySQL 8.0 支持** | ✓ | ✓ | ✓ |
| **MySQL 9.0 支持** | ✓ | ✓ | ✓ |
| **MariaDB 支持** | ✓ (基础) | ✓ | ✗ (官方不支持) |

### 15.2 设计取舍

NewLife.MySql 作为轻量级驱动，有意不实现以下功能：

| 不实现的功能 | 原因 |
|-------------|------|
| EF Core 支持 | 目标用户使用 XCode/DAL，无需 EF |
| DbBatch / DbDataSource | 通过多语句已满足批量需求，无需新 API |
| 压缩协议 | 内网部署为主，压缩收益有限 |
| 负载均衡/故障转移 | 应由中间件或 XCode 层处理 |
| LOAD DATA LOCAL | 安全风险，场景少 |
| 二进制协议（Prepared Statement 行数据） | 文本协议已满足需求，且调试更直观 |

### 15.3 性能优势

- **零额外分配**：使用 `ArrayPool` 和 `OwnerPacket` 减少 GC 压力
- **真异步 IO**：全链路 async/await，无 sync-over-async
- **客户端参数替换**：减少服务端 Prepare/Execute 往返
- **连接池复用**：SqlClient 级别复用，连接保持打开
- **精简协议实现**：只解析必要字段，跳过冗余数据
