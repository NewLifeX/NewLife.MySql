# NewLife.MySql 批量操作性能测试报告

## 1. 测试概述

本报告对 NewLife.MySql 的 **INSERT / UPDATE / DELETE** 三种批量操作进行基准性能测试，每种操作覆盖 7 种方案（含自动提交和事务两种模式，共 36 个测试用例），对比在 100 / 1000 / 10000 三种数据量级下的真实执行性能。同时对比 NewLife.MySql、MySql.Data（Oracle 官方）、MySqlConnector（社区）三种驱动在增删改查四种操作上的性能差异。

> **本报告所有数据均为真实测试结果**，`innodb_flush_log_at_trx_commit=1`（MySQL 默认值）。

### 测试方案

三种操作共用相同的方案矩阵，文本拼接方案因操作类型不同而有所变化：

| 方案 | 编号 | API | 协议 | 说明 |
|------|:----:|-----|------|------|
| 逐行操作 | 基线 | `ExecuteNonQuery` × N | 文本协议 | 每行一条 SQL，最慢基线 |
| 字典参数集 | A | `ExecuteBatch` | 二进制协议（Prepare+Execute×N） | 自动预编译，字典传参 |
| 数组绑定 | B | `ExecuteArrayBatch` | 二进制协议（Prepare+Execute×N） | Oracle 风格数组绑定 |
| 字典 + 管道化 | C-1 | `ExecuteBatch` + `Pipeline=true` | 二进制协议（管道化） | 批量发送后批量接收 |
| 数组 + 管道化 | C-2 | `ExecuteArrayBatch` + `Pipeline=true` | 二进制协议（管道化） | 最高性能方案 |
| 文本拼接 | D | INSERT: 多行 VALUES / UPDATE: 多语句分号拼接 / DELETE: IN() | 文本协议 | SQL 拼接批量 |
| DbBatch | E | `CreateBatch` (.NET 6+) | 文本协议（多语句） | ADO.NET 标准批量 |

### 测试环境

```
运行时: .NET 10.0
操作系统: Windows 11
MySQL: 8.0.26 (InnoDB, innodb_flush_log_at_trx_commit=1)
网络: 本机回环（127.0.0.1）
测试工具: Stopwatch 计时，每方案 1 轮预热 + 3 轮测量取中位数
```

### 测试表结构

```sql
CREATE TABLE bench_users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(64) NOT NULL,
    age INT NOT NULL,
    email VARCHAR(128),
    score DOUBLE,
    created DATETIME NOT NULL,
    INDEX idx_age(age)
) ENGINE=InnoDB;
```

## 2. 测试结果

> 以下数据为本机回环（127.0.0.1）测试结果，MySQL 8.0.26，`innodb_flush_log_at_trx_commit=1`（默认值）。

### 2.1 INSERT

#### 自动提交模式

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| SingleRow INSERT | 基线 | 37.79ms | 541.58ms | 3,505.22ms |
| ExecuteBatch | 串行 | 44.02ms | 307.58ms | 3,064.31ms |
| ExecuteArrayBatch | 串行 | 38.50ms | 282.10ms | 2,533.71ms |
| ExecuteBatch+Pipeline | 管道化 | 21.93ms | 198.61ms | 1,520.45ms |
| ExecuteArrayBatch+Pipeline | 管道化 | 11.87ms | 124.04ms | 1,197.71ms |
| **Multi-row VALUES** | **文本** | **3.22ms** | **27.28ms** | **244.32ms** |
| DbBatch API | 文本 | 13.53ms | 179.69ms | 2,562.48ms |

#### 事务模式

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| SingleRow INSERT (tx) | 事务 | 36.80ms | 307.58ms | 2,676.51ms |
| ExecuteBatch (tx) | 事务 | 18.00ms | 222.43ms | 1,653.67ms |
| ExecuteArrayBatch (tx) | 事务 | 27.16ms | 281.44ms | 1,713.50ms |
| ExecuteBatch+Pipeline (tx) | 事务+管道 | 13.57ms | 125.90ms | 779.18ms |
| **ExecuteArrayBatch+Pipeline (tx)** | **事务+管道** | **9.37ms** | **101.12ms** | **680.27ms** |

#### 加速比（相对 SingleRow INSERT 基线）

| 方案 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| SingleRow INSERT | 1.0x | 1.0x | 1.0x |
| ExecuteBatch | 0.9x | 1.8x | 1.1x |
| ExecuteArrayBatch | 1.0x | 1.9x | 1.4x |
| ExecuteBatch+Pipeline | 1.7x | 2.7x | 2.3x |
| ExecuteArrayBatch+Pipeline | 3.2x | 4.4x | 2.9x |
| **Multi-row VALUES** | **11.7x** | **19.9x** | **14.3x** |
| DbBatch API | 2.8x | 3.0x | 1.4x |
| SingleRow INSERT (tx) | 1.0x | 1.8x | 1.3x |
| ExecuteBatch (tx) | 2.1x | 2.4x | 2.1x |
| ExecuteArrayBatch (tx) | 1.4x | 1.9x | 2.0x |
| ExecuteBatch+Pipeline (tx) | 2.8x | 4.3x | 4.5x |
| **ExecuteArrayBatch+Pipeline (tx)** | **4.0x** | **5.4x** | **5.2x** |

### 2.2 UPDATE

> UPDATE 按主键 `id` 逐行更新 `age` 字段。文本拼接方案使用多条 `UPDATE` 语句分号拼接提交。

#### 自动提交模式

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| SingleRow UPDATE | 基线 | 26.98ms | 275.54ms | 4,183.91ms |
| ExecuteBatch UPDATE | 串行 | 27.14ms | 254.91ms | 2,989.50ms |
| ExecuteArrayBatch UPDATE | 串行 | 36.28ms | 302.40ms | 3,002.27ms |
| ExecuteBatch+Pipeline UPDATE | 管道化 | 20.18ms | 105.90ms | - |
| ExecuteArrayBatch+Pipeline UPDATE | 管道化 | 9.63ms | 106.63ms | - |
| Multi-stmt UPDATE | 文本 | 12.78ms | 119.79ms | 2,910.20ms |
| DbBatch UPDATE | 文本 | 12.64ms | 124.87ms | 2,077.67ms |

> Pipeline UPDATE 10000 行报超时（-），与 UPDATE 的行级锁持有时间较长有关，后续版本优化中。

#### 事务模式

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| SingleRow UPDATE (tx) | 事务 | 25.61ms | 276.49ms | 2,763.51ms |
| ExecuteBatch UPDATE (tx) | 事务 | 28.14ms | 158.61ms | 1,974.36ms |
| ExecuteArrayBatch UPDATE (tx) | 事务 | 25.78ms | 172.30ms | 1,887.93ms |
| ExecuteBatch+Pipeline UPDATE (tx) | 事务+管道 | 15.57ms | 67.64ms | - |
| **ExecuteArrayBatch+Pipeline UPDATE (tx)** | **事务+管道** | **11.42ms** | **56.66ms** | - |

#### 加速比（相对 SingleRow UPDATE 基线）

| 方案 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| SingleRow UPDATE | 1.0x | 1.0x | 1.0x |
| ExecuteBatch UPDATE | 1.0x | 1.1x | 1.4x |
| ExecuteArrayBatch UPDATE | 0.7x | 0.9x | 1.4x |
| ExecuteBatch+Pipeline UPDATE | 1.3x | 2.6x | - |
| ExecuteArrayBatch+Pipeline UPDATE | 2.8x | 2.6x | - |
| Multi-stmt UPDATE | 2.1x | 2.3x | 1.4x |
| DbBatch UPDATE | 2.1x | 2.2x | 2.0x |
| SingleRow UPDATE (tx) | 1.1x | 1.0x | 1.5x |
| ExecuteBatch UPDATE (tx) | 1.0x | 1.7x | 2.1x |
| ExecuteArrayBatch UPDATE (tx) | 1.0x | 1.6x | 2.2x |
| ExecuteBatch+Pipeline UPDATE (tx) | 1.7x | 4.1x | - |
| **ExecuteArrayBatch+Pipeline UPDATE (tx)** | **2.4x** | **4.9x** | - |

### 2.3 DELETE

> DELETE 按主键 `id` 逐行删除。文本拼接方案使用 `WHERE id IN(...)` 合并为单条 SQL。

#### 自动提交模式

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| SingleRow DELETE | 基线 | 27.61ms | 290.75ms | 4,273.90ms |
| ExecuteBatch DELETE | 串行 | 28.90ms | 233.26ms | 3,054.49ms |
| ExecuteArrayBatch DELETE | 串行 | 33.37ms | 246.10ms | 2,934.51ms |
| ExecuteBatch+Pipeline DELETE | 管道化 | 13.22ms | 163.88ms | 1,698.62ms |
| ExecuteArrayBatch+Pipeline DELETE | 管道化 | 12.12ms | 105.73ms | 1,338.25ms |
| **IN() DELETE** | **文本** | **1.79ms** | **5.12ms** | **116.46ms** |
| DbBatch DELETE | 文本 | 8.04ms | 206.41ms | 1,282.65ms |

#### 事务模式

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| SingleRow DELETE (tx) | 事务 | 27.57ms | 323.10ms | 2,460.74ms |
| ExecuteBatch DELETE (tx) | 事务 | 16.86ms | 228.46ms | 2,334.23ms |
| ExecuteArrayBatch DELETE (tx) | 事务 | 19.13ms | 289.79ms | 2,133.45ms |
| **ExecuteBatch+Pipeline DELETE (tx)** | **事务+管道** | **5.99ms** | **81.60ms** | **618.18ms** |
| ExecuteArrayBatch+Pipeline DELETE (tx) | 事务+管道 | 13.88ms | 76.82ms | 818.21ms |

#### 加速比（相对 SingleRow DELETE 基线）

| 方案 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| SingleRow DELETE | 1.0x | 1.0x | 1.0x |
| ExecuteBatch DELETE | 1.0x | 1.2x | 1.4x |
| ExecuteArrayBatch DELETE | 0.8x | 1.2x | 1.5x |
| ExecuteBatch+Pipeline DELETE | 2.1x | 1.8x | 2.5x |
| ExecuteArrayBatch+Pipeline DELETE | 2.3x | 2.7x | 3.2x |
| **IN() DELETE** | **15.5x** | **56.8x** | **36.7x** |
| DbBatch DELETE | 3.4x | 1.4x | 3.3x |
| SingleRow DELETE (tx) | 1.0x | 0.9x | 1.7x |
| ExecuteBatch DELETE (tx) | 1.6x | 1.3x | 1.8x |
| ExecuteArrayBatch DELETE (tx) | 1.4x | 1.0x | 2.0x |
| **ExecuteBatch+Pipeline DELETE (tx)** | **4.6x** | **3.6x** | **6.9x** |
| ExecuteArrayBatch+Pipeline DELETE (tx) | 2.0x | 3.8x | 5.2x |

### 2.4 关键发现

#### 发现一：三种操作呈现一致的性能分层

| 方案类型 | INSERT 10000行 | UPDATE 10000行 | DELETE 10000行 | 规律 |
|---------|------:|------:|------:|------|
| 逐行（autocommit 基线） | 3,505ms | 4,184ms | 4,274ms | 基线相近 |
| 串行（ExecuteBatch） | 3,064ms | 2,990ms | 3,055ms | 1.1~1.4x |
| Pipeline（autocommit） | 1,198ms | - | 1,338ms | 2~3x |
| 文本拼接 | **244ms** | **2,910ms** | **116ms** | INSERT/DELETE 极快 |
| 事务+Pipeline | **680ms** | - | **618ms** | 5~7x |

**核心结论**：
- INSERT 的 Multi-row VALUES 和 DELETE 的 IN() 是各自操作中的最快方案，因为单条 SQL = 单次网络往返 + 单次 fsync + 服务端批量优化
- UPDATE 的多语句拼接本质上等同于 DbBatch（都是分号分隔的多语句），性能约 1.4x，不如 INSERT/DELETE 的文本方案优势明显
- `innodb_flush_log_at_trx_commit=1` 下，事务模式收益显著提升，因为事务将多次 fsync 合并为一次

#### 发现二：UPDATE 的文本拼接与 DbBatch 本质相同

- UPDATE 的多语句分号拼接（2,910ms）和 DbBatch（2,078ms）性能接近，因为两者本质相同——都是分号分隔的多条 UPDATE 一次性提交
- 不像 INSERT（Multi-row VALUES 是合并为单条 SQL）和 DELETE（IN() 也是单条 SQL），UPDATE 无法合并为单条 SQL
- **IN() DELETE** 效率最高（36.7x）：主键 IN 查询走索引批量删除，单条 SQL 服务端批量优化
- **Multi-row VALUES INSERT**（14.3x）：单条 SQL + InnoDB 批量索引合并

#### 发现三：Pipeline 对 UPDATE 大数据量存在限制

Pipeline UPDATE 在 10000 行时超时，原因分析：
- UPDATE 需要持有行级排他锁，10000 行连续锁定压力大
- 管道化一次性发送大量 UPDATE，服务端需逐行加锁执行
- **建议**：大批量 UPDATE 使用管道化时，分批处理（如每批 1000~2000 行）

#### 发现四：管道化在所有操作中都有显著收益

事务模式下管道化的加速效果：

| 操作 | Pipeline(tx) vs 串行(tx) 1000行 | Pipeline(tx) vs 逐行 1000行 |
|------|------:|------:|
| INSERT | 2.2x | 5.4x |
| UPDATE | 2.8x (ExecuteBatch) | 4.9x |
| DELETE | 2.8x (ExecuteBatch) | 3.6x |

## 3. 方案选择指南

### 3.1 决策矩阵（基于真实测试数据）

#### INSERT

| 场景 | 推荐方案 | 实测性能（10000行） | 理由 |
|------|---------|---------|------|
| 纯 INSERT（任意规模） | **Multi-row VALUES** | 244ms（14.3x） | 所有场景最快，单条 SQL |
| 大批量 + 参数化 | **数组绑定 + Pipeline + 事务** | 680ms（5.2x） | 参数化安全 + 管道化高效 |
| 中等批量 + 事务 | ExecuteBatch / ExecuteArrayBatch + 事务 | 1,654~1,714ms | 预编译优化 |
| 混合 SQL 批量 | DbBatch | 2,562ms（1.4x） | ADO.NET 标准兼容 |

#### UPDATE

| 场景 | 推荐方案 | 实测性能（10000行） | 理由 |
|------|---------|---------|------|
| 按主键批量更新 | **多语句分号拼接** | 2,910ms（1.4x） | 标准文本拼接，与 DbBatch 等效 |
| 参数化批量更新 | **ExecuteArrayBatch + Pipeline + 事务** | 57ms/1000行（4.9x） | 管道化 + 预编译 |
| 中等批量 + 事务 | ExecuteBatch / ExecuteArrayBatch + 事务 | 1,888~1,974ms | 预编译优化 |

#### DELETE

| 场景 | 推荐方案 | 实测性能（10000行） | 理由 |
|------|---------|---------|------|
| 按主键批量删除 | **IN() DELETE** | 116ms（36.7x） | 单条 SQL + 索引批量删除 |
| 参数化批量删除 | **Pipeline + 事务** | 618~818ms（5.2~6.9x） | 管道化消除网络等待 |
| 中等批量 + 事务 | ExecuteBatch / ExecuteArrayBatch + 事务 | 2,133~2,334ms | 预编译优化 |

### 3.2 重要：事务与文本拼接的威力

> **核心结论**：三种操作的性能优化策略一致——**文本拼接是最快方案，事务+管道化是参数化方案的最佳组合**。

| 操作 | 文本拼接方案 | 加速比 | Pipeline(tx) 最佳 | 加速比 |
|------|---------|------:|---------|------:|
| INSERT | Multi-row VALUES | 14.3x | ArrayBatch+Pipeline(tx) | 5.2x |
| UPDATE | 多语句分号拼接 | 1.4x | ArrayBatch+Pipeline(tx) | 4.9x (1000行) |
| DELETE | IN() | 36.7x | Pipeline(tx) | 6.9x |

### 3.3 管道化模式性能提升

本机回环实测数据（事务模式，1000行）：

| 操作 | Pipeline(tx) vs 串行(tx) | Pipeline(tx) vs 逐行 |
|------|------:|------:|
| INSERT | 2.2x | 5.4x |
| UPDATE | 2.8x | 4.9x |
| DELETE | 2.8x | 3.6x |

跨网络场景估算（网络延迟越高，管道化收益越大）：

| 网络环境 | RTT | 1000 行估算加速比 | 10000 行估算加速比 |
|---------|-----|:------------:|:-------------:|
| 本机回环 | ~0.1ms | 2~4x（实测） | 3~5x（实测） |
| 同机房 | ~0.5ms | ~5x | ~10x |
| 跨机房 | ~5ms | ~12x | ~25x |
| 跨地域 | ~30ms | ~25x | ~60x |

## 4. 运行基准测试

### 4.1 前置条件

1. 安装 MySQL 8.0+，确保可访问
2. 创建测试数据库和表

```sql
CREATE DATABASE IF NOT EXISTS benchmark;
USE benchmark;

CREATE TABLE IF NOT EXISTS bench_users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(64) NOT NULL,
    age INT NOT NULL,
    email VARCHAR(128),
    score DOUBLE,
    created DATETIME NOT NULL
) ENGINE=InnoDB;
```

### 4.2 运行命令

```bash
# 快速测试（Stopwatch 计时，INSERT+UPDATE+DELETE 约 20 分钟）
cd Benchmark
dotnet run -c Release -- --quick

# 三驱动对比测试（NewLife vs MySql.Data vs MySqlConnector）
dotnet run -c Release -- --driver

# BenchmarkDotNet 完整测试（仅 INSERT，约 30+ 分钟）
dotnet run -c Release

# 自定义连接字符串
set MYSQL_CONNSTR=Server=192.168.1.100;Port=3306;Database=benchmark;User Id=root;Password=pass;
dotnet run -c Release -- --quick
```

### 4.3 注意事项

- `--quick` 模式使用 Stopwatch 计时（1轮预热 + 3轮测量取中位数），覆盖 INSERT/UPDATE/DELETE 三种操作
- `--driver` 模式对比三种驱动（NewLife.MySql / MySql.Data / MySqlConnector）的单行与批量操作性能
- 不带 `--quick` 参数运行 BenchmarkDotNet 完整测试（仅 INSERT），结果更精确
- 测试脚本会自动创建数据库和表（含索引），无需手动执行 SQL
- UPDATE/DELETE 每轮测试前自动填充种子数据
- `max_allowed_packet` 影响多行 VALUES 的分批大小（测试中每批 1000 行）
- Pipeline UPDATE 在 10000 行时可能超时，建议分批处理

## 5. 性能优化建议

### 5.1 通用建议（基于实测验证）

1. **文本拼接方案 INSERT/DELETE 最快**：Multi-row VALUES / IN() 在这两种操作中最快
2. **UPDATE 最佳方案是 Pipeline + 事务**：文本拼接对 UPDATE 收益有限，管道化才是王道
2. **参数化场景用管道化+事务**：`Pipeline=true` + `BeginTransaction()` 是参数化方案的最佳组合
3. **复用连接**：连接池自动管理，避免频繁创建/销毁连接
4. **调整 MySQL 配置**：
   - `max_allowed_packet` ≥ 64M（大批量 SQL）
   - `innodb_flush_log_at_trx_commit = 2`（批量导入场景，可额外提速）
   - `innodb_buffer_pool_size`（充足的缓冲池）

### 5.2 各操作专项优化

#### INSERT
- **首选 Multi-row VALUES**：10000行 203ms，简单高效
- 参数化场景用 `ExecuteArrayBatch` + `Pipeline=true` + 事务
- 禁用自增锁竞争：`innodb_autoinc_lock_mode = 2`
- 关闭唯一性/外键检查（导入完成后恢复）

#### UPDATE
- **首选 Pipeline + 事务**：`ExecuteArrayBatch` + `Pipeline=true` + 事务，1000 行 57ms（4.9x）
- 文本拼接：多条 `UPDATE t SET col=v WHERE id=x;` 分号拼接，性能与 DbBatch 相当（1.4x）
- 大批量管道化 UPDATE 需分批（每批 1000~2000 行），避免超时
- 确保 WHERE 条件走索引

#### DELETE
- **首选 IN() DELETE**：`DELETE FROM t WHERE id IN(1,2,3,...)`，10000行 116ms
- 参数化场景用 Pipeline + 事务
- 大批量删除考虑分批，避免长事务

### 5.3 连接字符串推荐配置

```
# 大数据批量场景推荐配置
Server=localhost;Database=mydb;User Id=root;Password=pass;Pipeline=true;CommandTimeout=120;
```

### 5.4 最佳实践代码示例

```csharp
// INSERT: 数组绑定 + 管道化 + 事务
var connStr = "Server=localhost;Database=mydb;User Id=root;Password=pass;Pipeline=true;";
using var conn = new MySqlConnection(connStr);
conn.Open();
using var tr = conn.BeginTransaction();
using var cmd = new MySqlCommand(conn, "INSERT INTO users(name,age) VALUES(@name,@age)");
cmd.Parameters.AddWithValue("name", names);  // String[]
cmd.Parameters.AddWithValue("age", ages);    // Int32[]
cmd.ExecuteArrayBatch(count);
tr.Commit();

// UPDATE: 数组绑定 + 管道化 + 事务
using var cmd2 = new MySqlCommand(conn, "UPDATE users SET age=@age WHERE id=@id");
cmd2.Parameters.AddWithValue("age", newAges);  // Int32[]
cmd2.Parameters.AddWithValue("id", ids);       // Int64[]
cmd2.ExecuteArrayBatch(count);

// DELETE: 数组绑定 + 管道化 + 事务
using var cmd3 = new MySqlCommand(conn, "DELETE FROM users WHERE id=@id");
cmd3.Parameters.AddWithValue("id", ids);  // Int64[]
cmd3.ExecuteArrayBatch(count);
```

## 6. 总结

NewLife.MySql 在批量操作领域具备**独特的架构优势**，实测数据验证了以下结论：

### 6.1 三种操作性能排名（实测 10000 行）

#### INSERT
```
Multi-row VALUES (244ms, 14.3x) > ExecuteArrayBatch+Pipeline(tx) (680ms, 5.2x)
  > ExecuteBatch+Pipeline(tx) (779ms, 4.5x) > ExecuteArrayBatch+Pipeline (1,198ms, 2.9x)
  > ExecuteBatch(tx) (1,654ms, 2.1x) > SingleRow INSERT (3,505ms, 基线)
```

#### UPDATE
```
ExecuteArrayBatch+Pipeline(tx) (57ms/1000行, 4.9x) > DbBatch (2,078ms, 2.0x)
  > ExecuteArrayBatch(tx) (1,888ms, 2.2x) > Multi-stmt (2,910ms, 1.4x)
  > SingleRow UPDATE (4,184ms, 基线)
```

#### DELETE
```
IN() DELETE (116ms, 36.7x) > Pipeline(tx) (618~818ms, 5.2~6.9x)
  > DbBatch (1,283ms, 3.3x) > ExecuteArrayBatch(tx) (2,133ms, 2.0x)
  > SingleRow DELETE (4,274ms, 基线)
```

### 6.2 核心结论

1. **INSERT/DELETE 文本拼接极快**：Multi-row VALUES（14.3x）、IN() DELETE（36.7x），因为能合并为单条 SQL
2. **UPDATE 文本拼接收益有限**（1.4x）：多语句分号拼接本质等同于 DbBatch，无法合并为单条 SQL
3. **管道化执行（Pipeline）** 是其他主流 MySQL 驱动所不具备的能力，三种操作中均有 3~7x 加速
4. **UPDATE 最佳方案是 Pipeline + 事务**（4.9x），而非文本拼接
5. **参数化场景的最优组合**：ExecuteBatch/ExecuteArrayBatch + Pipeline + 事务
6. **innodb_flush_log_at_trx_commit=1 下事务收益显著提升**：事务将多次 fsync 合并为一次，加速更明显
7. **UPDATE 大批量管道化需分批**：10000 行时超时，建议每批 1000~2000 行

### 6.3 推荐组合

| 操作 | 首选（最高性能） | 次选（参数化安全） | 加速比 |
|------|---------|---------|------:|
| INSERT | Multi-row VALUES | ArrayBatch + Pipeline + 事务 | 14.3x / 5.2x |
| UPDATE | **Pipeline + 事务** | 多语句分号拼接 | **4.9x** / 1.4x |
| DELETE | IN() DELETE | Pipeline + 事务 | 36.7x / 6.9x |

## 7. 驱动对比测试

> 对比 **NewLife.MySql**、**MySql.Data**（Oracle 官方 9.6.0）、**MySqlConnector**（社区 2.5.0）三种 .NET MySQL 驱动的性能差异。
> 每种驱动测试两种模式：**逐行操作（SingleRow）** 和 **参数化预编译+事务（Batch/Pipeline）**。
> NewLife.MySql 的 Pipeline(tx) 使用管道化 + 数组绑定 + 事务；其他驱动使用 Prepare + 参数复用 + 事务。

### 7.1 INSERT（中位数 ms）

| 驱动 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| NewLife SingleRow | 55.73 | 477.95 | 4,466.45 |
| **NewLife Pipeline(tx)** | **12.65** | **222.79** | **831.27** |
| Official SingleRow | 61.55 | 569.46 | 4,496.07 |
| Official Batch(tx) | 33.41 | 244.46 | 2,656.92 |
| Connector SingleRow | 59.40 | 523.34 | 4,496.17 |
| Connector Batch(tx) | 42.02 | 425.74 | 2,994.20 |

### 7.2 SELECT（中位数 ms）

| 驱动 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| NewLife SingleRow | 62.43 | 420.01 | 3,577.45 |
| Official SingleRow | 81.93 | 448.00 | 3,721.09 |
| **Connector SingleRow** | **31.54** | **283.92** | **2,600.62** |

### 7.3 UPDATE（中位数 ms）

| 驱动 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| NewLife SingleRow | 63.33 | 457.74 | 3,694.62 |
| **NewLife Pipeline(tx)** | **11.60** | **170.74** | - |
| Official SingleRow | 55.62 | 400.30 | 4,374.14 |
| Official Batch(tx) | 43.92 | 250.19 | 2,173.11 |
| Connector SingleRow | 46.22 | 388.62 | 3,035.54 |
| Connector Batch(tx) | 33.35 | 214.98 | 2,194.79 |

> NewLife Pipeline UPDATE 10000 行超时（已知限制，建议分批 1000~2000 行）。

### 7.4 DELETE（中位数 ms）

| 驱动 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| NewLife SingleRow | 51.02 | 350.10 | 3,964.71 |
| **NewLife Pipeline(tx)** | **15.10** | **136.61** | **724.29** |
| Official SingleRow | 59.12 | 431.45 | 4,831.47 |
| Official Batch(tx) | 36.66 | 246.74 | 2,203.36 |
| Connector SingleRow | 47.27 | 421.40 | 3,082.49 |
| Connector Batch(tx) | 43.43 | 222.98 | 2,119.03 |

### 7.5 驱动对比关键发现

#### 发现一：逐行操作三驱动性能接近

| 操作 | NewLife | Official | Connector | 差异 |
|------|------:|------:|------:|------|
| INSERT 10000 | 4,466ms | 4,496ms | 4,496ms | < 1% |
| UPDATE 10000 | 3,695ms | 4,374ms | 3,036ms | Connector 略快 |
| DELETE 10000 | 3,965ms | 4,831ms | 3,082ms | Connector 略快 |

逐行 autocommit 模式下，瓶颈在 MySQL 服务端的逐次 fsync，驱动层差异被掩盖。

#### 发现二：NewLife Pipeline(tx) 大幅领先

| 操作 | NewLife Pipeline(tx) | Official Batch(tx) | Connector Batch(tx) | Pipeline 优势 |
|------|------:|------:|------:|------|
| INSERT 10000 | **831ms** | 2,657ms | 2,994ms | **3.2~3.6x** |
| UPDATE 1000 | **171ms** | 250ms | 215ms | **1.3~1.5x** |
| DELETE 10000 | **724ms** | 2,203ms | 2,119ms | **2.9~3.0x** |

NewLife.MySql 的管道化执行在批量场景下远超其他驱动的 Prepare+事务方案，因为管道化消除了逐条等待响应的网络延迟。

#### 发现三：SELECT 领域 MySqlConnector 领先

MySqlConnector 的 SELECT 查询性能最优（2,601ms vs NewLife 3,577ms vs Official 3,721ms），其异步 I/O 和结果集解析优化较为成熟。NewLife.MySql 的 SELECT 性能有优化空间。
