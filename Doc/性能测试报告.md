# NewLife.MySql 批量操作性能测试报告

## 1. 测试概述

本报告对 NewLife.MySql 的**七种批量 INSERT 方案**（含自动提交和事务两种模式，共 12 个测试用例）进行基准性能测试，对比不同方案在 100 / 1000 / 10000 三种数据量级下的真实执行性能，帮助用户根据实际场景选择最优方案。

> **本报告所有数据均为真实测试结果**，非理论预估。

### 测试方案

| 方案 | 编号 | API | 协议 | 说明 |
|------|:----:|-----|------|------|
| 逐行 INSERT | 基线 | `ExecuteNonQuery` × N | 文本协议 | 每行一条 SQL，最慢基线 |
| 字典参数集 | A | `ExecuteBatch` | 二进制协议（Prepare+Execute×N） | 自动预编译，字典传参 |
| 数组绑定 | B | `ExecuteArrayBatch` | 二进制协议（Prepare+Execute×N） | Oracle 风格数组绑定 |
| 字典 + 管道化 | C-1 | `ExecuteBatch` + `Pipeline=true` | 二进制协议（管道化） | 批量发送后批量接收 |
| 数组 + 管道化 | C-2 | `ExecuteArrayBatch` + `Pipeline=true` | 二进制协议（管道化） | 最高性能方案 |
| 多行 VALUES | D | 文本拼接 `INSERT ... VALUES (...),(...)` | 文本协议 | SQL 拼接批量 |
| DbBatch | E | `CreateBatch` (.NET 6+) | 文本协议（多语句） | ADO.NET 标准批量 |

### 测试环境

```
运行时: .NET 10.0
操作系统: Windows 11
MySQL: 8.0.26 (InnoDB, innodb_flush_log_at_trx_commit=1)
网络: 本机回环（127.0.0.1）
测试工具: Stopwatch 计时，每方案 1 轮预热 + 3 轮测量取中位数
```

### 测试表结构

```sql
CREATE TABLE bench_users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(64) NOT NULL,
    age INT NOT NULL,
    email VARCHAR(128),
    score DOUBLE,
    created DATETIME NOT NULL
) ENGINE=InnoDB;
```

## 2. 测试结果

### 2.1 真实性能数据

> 以下数据为本机回环（localhost）测试结果，MySQL 8.0.26 默认配置（`innodb_flush_log_at_trx_commit=1`）。

#### 自动提交模式（autocommit=1）

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| 逐行 INSERT | 基线 | 545.79ms | 5,721.26ms | 58,042.63ms |
| ExecuteBatch（字典参数集） | 串行 | 587.78ms | 5,526.38ms | 56,861.87ms |
| ExecuteArrayBatch（数组绑定） | 串行 | 590.07ms | 5,767.80ms | 59,333.77ms |
| ExecuteBatch+Pipeline（管道化） | 管道化 | 558.77ms | 5,296.78ms | 55,897.98ms |
| ExecuteArrayBatch+Pipeline（管道化） | 管道化 | 572.68ms | 5,915.11ms | 57,106.02ms |
| **多行 INSERT VALUES** | **文本** | **11.17ms** | **45.18ms** | **423.94ms** |
| DbBatch API | 文本 | 569.71ms | 5,687.64ms | 1,915.49ms |

#### 事务模式（BEGIN...COMMIT 包裹）

| 方案 | 类别 | 100 行 | 1000 行 | 10000 行 |
|------|------|------:|------:|------:|
| 逐行 INSERT（事务） | 事务 | 25.30ms | 335.42ms | 3,004.15ms |
| ExecuteBatch（事务） | 事务 | 23.38ms | 276.06ms | 2,401.25ms |
| ExecuteArrayBatch（事务） | 事务 | 21.58ms | 315.55ms | 2,216.03ms |
| ExecuteBatch+Pipeline（事务） | 事务+管道 | 14.51ms | 189.17ms | 734.51ms |
| **ExecuteArrayBatch+Pipeline（事务）** | **事务+管道** | **31.27ms** | **150.72ms** | **667.60ms** |

#### 加速比（相对于逐行 INSERT autocommit 基线）

| 方案 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| 逐行 INSERT | 1.0x | 1.0x | 1.0x |
| ExecuteBatch | 0.9x | 1.0x | 1.0x |
| ExecuteArrayBatch | 0.9x | 1.0x | 1.0x |
| ExecuteBatch+Pipeline | 1.0x | 1.1x | 1.0x |
| ExecuteArrayBatch+Pipeline | 1.0x | 1.0x | 1.0x |
| **多行 INSERT VALUES** | **48.9x** | **126.6x** | **136.9x** |
| DbBatch API | 1.0x | 1.0x | 30.3x |
| 逐行 INSERT（事务） | 21.6x | 17.1x | 19.3x |
| ExecuteBatch（事务） | 23.3x | 20.7x | 24.2x |
| ExecuteArrayBatch（事务） | 25.3x | 18.1x | 26.2x |
| ExecuteBatch+Pipeline（事务） | 37.6x | 30.2x | **79.0x** |
| **ExecuteArrayBatch+Pipeline（事务）** | 17.5x | **38.0x** | **86.9x** |

### 2.2 关键发现

#### 发现一：autocommit 下 InnoDB fsync 是绝对瓶颈

在 `innodb_flush_log_at_trx_commit=1`（默认值）下，**每条 INSERT 都触发一次 redo log fsync**，每次 fsync 约 5~6ms。这导致：

- 逐行 INSERT 10000 行耗时 **58 秒**（约 5.8ms/行 = fsync 延迟）
- 所有串行方案（ExecuteBatch / ExecuteArrayBatch / Pipeline）耗时几乎相同
- 协议优化（二进制 vs 文本、管道化 vs 串行）的收益被 fsync 完全掩盖

```
autocommit=1 时：
  总耗时 ≈ N × fsync延迟(~5.8ms) >> N × 网络延迟(~0.1ms)
  因此：所有串行方案性能相近，管道化无法发挥优势
```

#### 发现二：事务模式消除 fsync 后管道化优势立刻显现

事务包裹后，整个批量只需 **1 次 fsync**，此时网络延迟成为主要瓶颈：

```
事务模式 10000 行耗时对比：
  逐行 INSERT（事务）:              3,004ms  (每行 0.3ms = 网络往返)
  ExecuteBatch（事务）:             2,401ms  (预编译减少解析)
  ExecuteArrayBatch（事务）:        2,216ms  (数组绑定更高效)
  ExecuteBatch+Pipeline（事务）:      735ms  (管道化消除网络等待)
  ExecuteArrayBatch+Pipeline（事务）: 668ms  (最优组合！)
```

事务模式下管道化的加速比：

| 对比 | 1000 行 | 10000 行 |
|------|------:|------:|
| Pipeline(tx) vs 逐行(tx) | 2.2x | 4.5x |
| Pipeline(tx) vs 逐行(autocommit) | 38.0x | 86.9x |

#### 发现三：多行 VALUES 在所有场景下性能最优

多行 `INSERT ... VALUES (...),(...)` 在所有测试场景中都是最快的：

- **100 行**：11ms（单条 SQL，单次网络往返，单次 fsync）
- **1000 行**：45ms（单条 SQL，InnoDB 批量索引合并）
- **10000 行**：424ms（分 10 批，每批 1000 行）

**原因**：每条多行 INSERT 语句是一个原子操作 = 一次事务 = 一次 fsync，且 InnoDB 可以合并索引更新，服务端处理效率远高于逐行。

### 2.3 各方案性能特征分析

#### 逐行 INSERT（基线）

```
每行操作 = 客户端构建SQL + 网络发送 + 服务端解析 + 服务端执行(含fsync) + 网络接收
总耗时 ≈ N × (SQL构建 + 2×网络延迟 + fsync延迟 + 服务端处理)
```

- 每行独立创建 `MySqlCommand`，有参数替换和对象分配开销
- 每行一次网络往返 + 一次 fsync
- **实测**：~5.8ms/行（autocommit），~0.3ms/行（事务）
- **适合**：少量数据、调试场景

#### 字典参数集 / 数组绑定（串行模式）

```
预编译 = 1次 COM_STMT_PREPARE 网络往返
每行操作 = 构建二进制包 + 网络发送 + 服务端执行(含fsync) + 网络接收
```

- 预编译一次，后续复用 `statementId`，省去 SQL 解析开销
- autocommit 下与逐行 INSERT 性能相近（fsync 主导）
- **事务模式下** 比逐行快 20~25%（省去 SQL 解析开销）
- **适合**：事务模式下的中等批量，参数来源灵活

#### 管道化模式（字典/数组 + Pipeline=true）

```
Phase1 = N × 构建包 + 批量发送 + 1次Flush
Phase2 = N × 服务端处理 + 批量接收
总耗时 ≈ 预编译耗时 + 批量发送 + N×处理 + 批量接收
```

- **核心优势**：网络往返仅一次，消除 N-1 次网络延迟等待
- **必须配合事务使用**：autocommit 下 fsync 掩盖管道化收益
- **事务模式实测**：10000 行 668ms → **86.9x 加速**
- **适合**：事务模式下的大批量（1000~100000行），跨机房高延迟场景

#### 多行 VALUES

```
总耗时 ≈ SQL拼接时间 + 1次网络发送 + 服务端批量插入(1次fsync) + 1次网络接收
```

- 单次网络往返 + 单次 fsync，即使在 autocommit 下也很快
- InnoDB 批量优化：合并索引更新、合并 redo log
- 需要注意 `max_allowed_packet` 限制（默认 4MB~64MB）
- **实测**：10000 行 424ms → **136.9x 加速**
- **适合**：纯 INSERT 场景，所有环境

#### DbBatch

```
总耗时 ≈ SQL拼接时间 + 1次网络发送 + N×服务端逐条处理(N×fsync) + 1次网络接收
```

- 内部拼接为分号分隔的多语句，减少网络往返
- 但每条 SQL 仍独立 fsync（autocommit 下）
- **实测**：100/1000 行与逐行相近；10000 行 1.9s（30.3x）表现较好
- **适合**：不同 SQL 混合执行，ADO.NET 标准兼容场景

## 3. 方案选择指南

### 3.1 决策矩阵（基于真实测试数据）

| 场景 | 推荐方案 | 实测性能 | 理由 |
|------|---------|---------|------|
| 纯 INSERT（任意规模） | **多行 VALUES** | 10000行 424ms（136.9x） | 所有场景最快，无需事务 |
| 大批量 + 参数化 | **数组绑定 + Pipeline + 事务** | 10000行 668ms（86.9x） | 参数化安全 + 管道化高效 |
| 大批量 + 动态参数 | **字典参数集 + Pipeline + 事务** | 10000行 735ms（79.0x） | 字典灵活 + 管道化 |
| 中等批量 + 事务 | ExecuteBatch / ExecuteArrayBatch + 事务 | 1000行 276~316ms（18~21x） | 预编译优化 |
| 少量数据（< 100 行） | 逐行 INSERT 或多行 VALUES | 差异不大 | 简单直接 |
| 混合 SQL 批量 | DbBatch | 10000行 1.9s（30.3x） | ADO.NET 标准兼容 |
| 跨机房/高延迟 | **Pipeline + 事务** | 延迟越高收益越大 | 管道化消除网络等待 |
| Oracle 迁移 | 数组绑定 | 与 Oracle ArrayBind 风格一致 | API 兼容 |

### 3.2 重要：事务对性能的决定性影响

> **核心结论**：在 `innodb_flush_log_at_trx_commit=1` 的生产配置下，不使用事务的批量操作几乎无法获得协议层面的性能收益。

| 模式 | 10000 行逐行 INSERT | 10000 行 Pipeline | 加速比 |
|------|------:|------:|------:|
| autocommit | 58,043ms | 57,106ms | 1.0x |
| **事务** | **3,004ms** | **668ms** | **4.5x** |

**最佳实践**：批量操作务必使用 `BeginTransaction()` + `Commit()` 包裹。

### 3.3 管道化模式性能提升（实测 + 估算）

本机回环实测数据（事务模式）：

| 对比 | 100 行 | 1000 行 | 10000 行 |
|------|------:|------:|------:|
| Pipeline(tx) vs 串行(tx) | 1.5x | 2.1x | 3.3x |
| Pipeline(tx) vs 逐行(autocommit) | 37.6x | 38.0x | 86.9x |

跨网络场景估算（网络延迟越高，管道化收益越大）：

| 网络环境 | RTT | 1000 行估算加速比 | 10000 行估算加速比 |
|---------|-----|:------------:|:-------------:|
| 本机回环 | ~0.1ms | 2.1x（实测） | 3.3x（实测） |
| 同机房 | ~0.5ms | ~4x | ~8x |
| 跨机房 | ~5ms | ~10x | ~20x |
| 跨地域 | ~30ms | ~20x | ~50x |

## 4. 运行基准测试

### 4.1 前置条件

1. 安装 MySQL 8.0+，确保可访问
2. 创建测试数据库和表

```sql
CREATE DATABASE IF NOT EXISTS benchmark;
USE benchmark;

CREATE TABLE IF NOT EXISTS bench_users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(64) NOT NULL,
    age INT NOT NULL,
    email VARCHAR(128),
    score DOUBLE,
    created DATETIME NOT NULL
) ENGINE=InnoDB;
```

### 4.2 运行命令

```bash
# 快速测试（Stopwatch 计时，约 10 分钟）
cd Benchmark
dotnet run -c Release -- --quick

# BenchmarkDotNet 完整测试（约 30+ 分钟）
dotnet run -c Release

# 自定义连接字符串
set MYSQL_CONNSTR=Server=192.168.1.100;Port=3306;Database=benchmark;User Id=root;Password=pass;
dotnet run -c Release -- --quick
```

### 4.3 注意事项

- `--quick` 模式使用 Stopwatch 计时（1轮预热 + 3轮测量取中位数），适合快速验证
- 不带 `--quick` 参数运行 BenchmarkDotNet 完整测试，结果更精确
- 测试脚本会自动创建数据库和表，无需手动执行 SQL
- `max_allowed_packet` 影响多行 VALUES 的分批大小（测试中每批 1000 行）
- **autocommit 下管道化收益被 fsync 掩盖**，真实收益需配合事务

## 5. 性能优化建议

### 5.1 通用建议（基于实测验证）

1. **🔴 必须使用事务包裹**：这是最关键的优化！实测事务模式比 autocommit 快 **19~87x**
2. **优先使用管道化模式**：事务 + `Pipeline=true` 实测 10000 行 668ms（86.9x）
3. **复用连接**：连接池自动管理，避免频繁创建/销毁连接
4. **调整 MySQL 配置**：
   - `max_allowed_packet` ≥ 64M（大批量 SQL）
   - `innodb_flush_log_at_trx_commit = 2`（批量导入场景，可额外提速 2~5x）
   - `innodb_buffer_pool_size`（充足的缓冲池）

### 5.2 批量 INSERT 专项优化

1. **🔴 事务包裹**：大批量操作**必须**放在事务中，实测效果：58s → 3s（10000行）
2. **禁用自增锁竞争**：`innodb_autoinc_lock_mode = 2`（交错模式）
3. **关闭唯一性检查**：`SET UNIQUE_CHECKS=0`（导入完成后恢复）
4. **关闭外键检查**：`SET FOREIGN_KEY_CHECKS=0`（导入完成后恢复）

### 5.3 连接字符串推荐配置

```
# 大数据批量场景推荐配置
Server=localhost;Database=mydb;User Id=root;Password=pass;Pipeline=true;CommandTimeout=120;
```

### 5.4 最佳实践代码示例

```csharp
// 最优方案：数组绑定 + 管道化 + 事务（实测 10000 行 668ms）
var connStr = "Server=localhost;Database=mydb;User Id=root;Password=pass;Pipeline=true;";
using var conn = new MySqlConnection(connStr);
conn.Open();
using var tr = conn.BeginTransaction();

using var cmd = new MySqlCommand(conn, "INSERT INTO users(name,age) VALUES(@name,@age)");
cmd.Parameters.AddWithValue("name", names);  // String[]
cmd.Parameters.AddWithValue("age", ages);    // Int32[]
var affected = cmd.ExecuteArrayBatch(count);

tr.Commit();
```

## 6. 总结

NewLife.MySql 在批量操作领域具备**独特的架构优势**，实测数据验证了以下结论：

### 6.1 性能排名（实测 10000 行）

```
多行 VALUES (424ms, 136.9x) > ExecuteArrayBatch+Pipeline+事务 (668ms, 86.9x)
  > ExecuteBatch+Pipeline+事务 (735ms, 79.0x) > DbBatch (1.9s, 30.3x)
  > ExecuteArrayBatch+事务 (2.2s, 26.2x) > ExecuteBatch+事务 (2.4s, 24.2x)
  > 逐行INSERT+事务 (3.0s, 19.3x) >> 逐行INSERT (58.0s, 基线)
```

### 6.2 核心结论

1. **事务是最关键的优化**：仅添加 `BeginTransaction()` + `Commit()`，性能提升 **19x**（58s → 3s）
2. **管道化执行（Pipeline）** 是其他主流 MySQL 驱动所不具备的能力，事务模式下实测 **86.9x 加速**
3. **多行 VALUES** 在所有场景下性能最优（**136.9x**），但不支持参数化
4. **数组绑定 + 管道化 + 事务** 是参数化场景的最优选择（**86.9x**），兼具安全性和性能
5. autocommit 下 InnoDB fsync 是绝对瓶颈，协议优化无法发挥作用

### 6.3 推荐组合

| 优先级 | 方案 | 加速比 | 适用场景 |
|:------:|------|------:|----------|
| 1 | 多行 VALUES | 136.9x | 纯 INSERT，数据可信 |
| 2 | ExecuteArrayBatch + Pipeline + 事务 | 86.9x | 参数化批量，推荐首选 |
| 3 | ExecuteBatch + Pipeline + 事务 | 79.0x | 动态参数批量 |
| 4 | ExecuteBatch/ArrayBatch + 事务 | 24~26x | 无需管道化的中等批量 |
